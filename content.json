{"meta":{"title":"Wuuu","subtitle":null,"description":null,"author":"wucb","url":"http://wucb.top"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2017-11-23T03:26:14.600Z","updated":"2017-11-23T03:12:52.332Z","comments":false,"path":"/404.html","permalink":"http://wucb.top//404.html","excerpt":"","text":""},{"title":"关于","date":"2017-11-23T03:26:14.600Z","updated":"2017-11-23T03:12:52.340Z","comments":false,"path":"about/index.html","permalink":"http://wucb.top/about/index.html","excerpt":"","text":"我就是我，是一样样的烟火，人群中你不认得我。。。"},{"title":"分类","date":"2017-11-23T03:26:14.601Z","updated":"2017-11-23T03:12:52.341Z","comments":false,"path":"categories/index.html","permalink":"http://wucb.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2017-11-23T03:26:14.601Z","updated":"2017-11-23T03:12:52.343Z","comments":true,"path":"links/index.html","permalink":"http://wucb.top/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2017-11-23T03:26:14.601Z","updated":"2017-11-23T03:12:52.344Z","comments":false,"path":"repository/index.html","permalink":"http://wucb.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-11-23T03:26:14.602Z","updated":"2017-11-23T03:12:52.345Z","comments":false,"path":"tags/index.html","permalink":"http://wucb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jmeter 并发测试工具","slug":"jmeter_use","date":"2017-12-15T08:06:06.000Z","updated":"2017-12-15T09:47:28.060Z","comments":true,"path":"2017/12/15/jmeter_use/","link":"","permalink":"http://wucb.top/2017/12/15/jmeter_use/","excerpt":"","text":"jmeter3.2 功能说明 1.模拟多线程发送请求。 2.测试定时和延时的功能。 3.请求数据，参数化配置。 4.请求的响应数据提取和供给其他请求使用。 5.计数器功能，解决唯一性校验问题。 6.聚合报告功能。 脚本录制。 推荐使用BlazeMeter(chrome插件)录制后，即可得到一个半成品的脚本。 用户参数。 添加全局变量 计数器 通过计数器 来设置一个会变的全局变量 登录用户名密码 加载文件 ，文件里面数据格式为username，pwd 结果提取 正则表达式 将结果 设置为全局变量 ${__setProperty(token,${token},)} 取值的时候用${__property(token)} 上传文件配置 如果上传失败尝试修改成java 如下图 Linux 测试 单台测试 启动命令 123456./apache-jmeter-3.2/bin/jmeter -n -t ./test/test-01.jmx -l ./test/test-01.jtl -j ./test/log.txt-n nogui 意思是不使用界面-t 后面跟要执行的测试脚本-l 后面跟测试结果保存的文件-j 日志文件 测试结果文件可以在gui界面加载 分布式测试server端配置 启动：1./apache-jmeter-3.2/bin/jmeter-server 默认远程1099端口，如果该端口已经被使用了，就需要修改bin目录下面的jmeter.propertis 配置文件修改server_port=1109，默认是1099. client 机器 负责调用 多个server进行测试，client 自己也可以是server启动 1./apache-jmeter-3.2/bin/jmeter -n -t ./test/test-01.jmx -R 192.168.16.67:11099 -l ./test/test-01.jtl -j ./test/log.txt -R后面跟server的ip和端口，过个用逗号隔开","categories":[{"name":"jmeter","slug":"jmeter","permalink":"http://wucb.top/categories/jmeter/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"http://wucb.top/tags/jmeter/"}]},{"title":"FastDFS 简介","slug":"fastdfs_des","date":"2017-12-13T03:10:34.000Z","updated":"2017-12-15T03:09:23.795Z","comments":true,"path":"2017/12/13/fastdfs_des/","link":"","permalink":"http://wucb.top/2017/12/13/fastdfs_des/","excerpt":"","text":"简介 作者：FastDFS是由国人余庆所开发 1.FastDFS是一个轻量级开源分布式文件系统2.主要解决了大容量的文件存储和高并发访问的问题。3.支持存储服务器在线扩容,支持相同的文件只保存一份 主要概念 1.tracker server 跟踪服务器：调度来自客户端的请求。返回可用的Storage server的IP地址和端口号2.storage server 存储服务器：用来存储文件(data)和文件属性(metadata)3.client 客户端：请求发起方，通过专用接口基于TCP协议与tracker以及storage server进行交互4.storage组\\卷 : 相互独立 上传流程1.客户端向tracker server发起请求2.tracker server返回可用的Storage server的地址和端口3.客户端链接该Storage server并上传文件4.Storage server返回上传后的文件地址 下载流程下载和上传的流程一致","categories":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://wucb.top/categories/FastDFS/"}],"tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://wucb.top/tags/FastDFS/"}]},{"title":"FastDFS_Docker安装","slug":"fastdfs_docker_conf","date":"2017-12-13T03:10:34.000Z","updated":"2017-12-18T03:24:21.227Z","comments":true,"path":"2017/12/13/fastdfs_docker_conf/","link":"","permalink":"http://wucb.top/2017/12/13/fastdfs_docker_conf/","excerpt":"","text":"在centos7下使用FastDFS的docker镜像 下载fastdfs的docker镜像 下载docker镜像: docker pull season/fastdfs fastdfs配置目录 下载好了一个镜像以后，在宿主机中新建目录用,于存放fastdfs配置文件和数据,名称根据自己需求，如下只是样例，fastdfs在一台服务器支持多个store_path，每个store_path指向一个存储路径etc(配置文件地址) storage_data(存储数据地址)，storage_data(存储数据地址) store_path(扩容)1234mkdir /usr/local/fastdfs/etc/ mkdir /usr/local/fastdfs/data/storage_datamkdir /usr/local/fastdfs/data/store_pathmkdir /usr/local/fastdfs/data/tracker_data 获取配置文件 启动一个fastdfs的docker容器，查看容器id，从容器中下载配置文件并且下载到上面创建的 /usr/local/fastdfs/etc/ 目录中. 123docker run -ti --name fdfs_sh --net=host season/fastdfs shdocker ps -a docker cp -a 07e7af1fdf74:/fdfs_conf/. /usr/local/fastdfs/etc 修改配置文件 主要修改的是文件存储目录和跟踪服务器地址，tracker_server 根据自己机器的地址进行配置 tracker.conf 主要修改如下几行 base_path=/fastdfs/storagestore_path0=/fastdfs/storage/tracker_server=192.168.1.214:22122 tracker.conf 主要修改如下几行 tracker_server=192.168.1.214:22122 client.conf修改如下几行 tracker_server=192.168.1.214:22122 启动容器 启动容器脚本,先启动一个tracker 然后再启动一个storage，-v 后面跟的目录映射，TRACKER_SERVER 地址根据自己机器的地址进行配置,--privileged=true 主要是解决目录权限12345678910111213docker run -tid --name trakcer \\ -v /usr/local/fastdfs/data/tracker_data/data:/fastdfs/tracker/data \\ -v /usr/local/fastdfs/etc:/fdfs_conf \\ --privileged=true \\ --net=host season/fastdfs trackerdocker run -tid --name storage \\ -v /usr/local/fastdfs/data/storage_data/data:/fastdfs/storage/data \\ -v /usr/local/fastdfs/data/store_path:/fastdfs/store_path \\ -v /usr/local/fastdfs/etc:/fdfs_conf \\ --privileged=true \\ --net=host -e TRACKER_SERVER:192.168.1.214:22122 \\ season/fastdfs storage 执行完上面的脚本会启动两个容器，使用docker ps可以进行查看,如果没有启动成功可以使用docker logs 容器id 查看日志 启动测试 还是启动一个容器，在容器中进行测试，启动容器会用到client.conf 1234docker run -ti --name fdfs_sh \\ -v /usr/local/fastdfs/etc:/fdfs_conf \\ --privileged=true \\ --net=host season/fastdfs sh 执行完脚本会自动进入容器，切换到/usr/bin然后执行上传文件。12cd /usr/binfdfs_test /fdfs_conf/client.conf upload /fdfs_conf/storage.conf 上传完成后会返回一些信息其中会包含文件地址,可以到宿主机目录进行查看 example file url: http://192.168.1.214/group1/M00/00/00/wKgB1lozOU-ASzg7AAAgC81RIQ441_big.conf 添加开放端口 添加开放端口，让fastdfs可以供其他程序调用要添加哪些端口可以在fastdfs配置文件中查找。1234firewall-cmd --zone=public --add-port=22122/tcp --permanentfirewall-cmd --zone=public --add-port=23000/tcp --permanentfirewall-cmd --zone=public --add-port=8088/tcp --permanentfirewall-cmd --reload","categories":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://wucb.top/categories/FastDFS/"}],"tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://wucb.top/tags/FastDFS/"}]},{"title":"FastDFS 使用Java上传下载文件","slug":"fastdfs_java","date":"2017-12-13T03:10:34.000Z","updated":"2017-12-15T06:03:28.226Z","comments":true,"path":"2017/12/13/fastdfs_java/","link":"","permalink":"http://wucb.top/2017/12/13/fastdfs_java/","excerpt":"","text":"前言 在java程序中上传文件到FastDFS，需要在项目中引入fastdfs-client-java包这个包在maven中央库中没有，可以自己下载源码后install下载源码 配置文件 在项目resource目录中加入配置文件fdfs_client.conf在配置文件中加入如下内容1234567connect_timeout = 2network_timeout = 30charset = UTF-8http.tracker_http_port = 8088http.anti_steal_token = nohttp.secret_key = FastDFS1234567890tracker_server = 192.168.1.214:22122 maven12345678910&lt;dependency&gt; &lt;groupId&gt;org.csource&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.example;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.util.Arrays;import org.apache.commons.io.IOUtils;import org.apache.tomcat.util.codec.binary.Base64;import org.csource.common.NameValuePair;import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.DownloadCallback;import org.csource.fastdfs.StorageClient;import org.csource.fastdfs.StorageClient1;import org.csource.fastdfs.StorageServer;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;import javax.servlet.http.HttpServletResponse;import javax.websocket.server.PathParam;public class FastDFSTest &#123; public static void main(String[] args) throws Exception &#123; //加载配置文件的方式 String configFileName = \"fdfs_client.conf\"; try &#123; ClientGlobal.init(configFileName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; String path = \"F:\\\\project\\\\mypro\\\\easycode\\\\easycode-parent\\\\example-fastdfs\\\\src\\\\main\\\\resource\\\\fdfs_client.conf\"; File file = new File(path); //返回储存路径:M00/00/00/wKgB1loyOaKAPsmdAAABEmKjEk440.conf String[] files = uploadFile(file); System.out.println(Arrays.asList(files)); &#125; /** * 上传文件 */ public static String[] uploadFile(File file) throws IOException &#123; String uploadFileName = file.getName(); byte[] fileBuff = IOUtils.toByteArray(new FileInputStream(file));; String[] files = null; String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(\".\") + 1); // 建立连接 TrackerClient tracker = new TrackerClient(); TrackerServer trackerServer = tracker.getConnection(); StorageServer storageServer = null; StorageClient client = new StorageClient(trackerServer, storageServer); // 设置元信息 NameValuePair[] metaList = new NameValuePair[3]; metaList[0] = new NameValuePair(\"fileName\", uploadFileName); metaList[1] = new NameValuePair(\"fileExtName\", fileExtName); metaList[2] = new NameValuePair(\"fileLength\", String.valueOf(file.length())); // 上传文件 try &#123; files = client.upload_file(fileBuff, fileExtName, metaList); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; trackerServer.close(); &#125; return files; &#125; public void download(String fileId) throws FileNotFoundException &#123; FileOutputStream fileOutputStream = new FileOutputStream(\"tep\"); TrackerClient tracker = null; TrackerServer trackerServer = null; try &#123; //解码fileId byte[] bs = Base64.decodeBase64(fileId); fileId = new String(bs, \"UTF-8\"); // 建立连接 fastDFS方式 tracker = new TrackerClient(); trackerServer = tracker.getConnection(); StorageServer storageServer = null; StorageClient1 client = new StorageClient1(trackerServer, storageServer); //响应内容设置// response.setContentType(\"image/png\"); //查询fdfs client.download_file1(fileId, new DownloadCallback() &#123; /** * @parem arg0 文件大小 * @parem arg1 數據流 * @parem arg2每次返回的大小 */ public int recv(long arg0, byte[] arg1, int arg2) &#123; try &#123; //返回数据流 fileOutputStream.write(arg1, 0, arg2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return 0; &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; trackerServer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 查看本文源码","categories":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://wucb.top/categories/FastDFS/"}],"tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://wucb.top/tags/FastDFS/"}]},{"title":"6.RxJava+Hystrix 小例子","slug":"6.RxJava+Hystrix 小例子","date":"2017-12-08T06:38:12.000Z","updated":"2017-12-08T00:08:44.000Z","comments":true,"path":"2017/12/08/6.RxJava+Hystrix 小例子/","link":"","permalink":"http://wucb.top/2017/12/08/6.RxJava+Hystrix 小例子/","excerpt":"","text":"前言 Hystrix是什么在复杂的分布式系统中，可能有成百上千个依赖服务，这些服务由于某种故障，比如机房的不可靠性、网络服务商的不可靠性等因素，导致某个服务不可用，如果系统不隔离该不可用的服务，可能会导致整个系统不可用对Hystrix不做其他说明，看例子。 1234567891011121314new HystrixCommand&lt;String&gt;(HystrixCommandGroupKey.Factory.asKey(\"test\"), 1000) &#123; @Override protected String run() throws Exception &#123; //业务代码 return \"1\"; &#125; @Override protected String getFallback() &#123; //错误处理 return null; &#125;&#125;.observe() .doOnNext(str -&gt; System.out.println(str)) .subscribe(); maven 12345678910&lt;dependency&gt; &lt;groupId&gt;io.reactivex&lt;/groupId&gt; &lt;artifactId&gt;rxjava&lt;/artifactId&gt; &lt;version&gt;1.0.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt; &lt;artifactId&gt;hystrix-core&lt;/artifactId&gt; &lt;version&gt;1.4.10&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/categories/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/tags/RxJava/"},{"name":"异步编程","slug":"异步编程","permalink":"http://wucb.top/tags/异步编程/"}]},{"title":"5.RxJava线程控制Scheduler","slug":"5.RxJava线程控制Scheduler","date":"2017-12-06T03:25:36.000Z","updated":"2017-12-08T00:08:44.000Z","comments":true,"path":"2017/12/06/5.RxJava线程控制Scheduler/","link":"","permalink":"http://wucb.top/2017/12/06/5.RxJava线程控制Scheduler/","excerpt":"","text":"前言 在RxJava 中Scheduler 就是用来控制线程，比如我写的一段代码想要在新的线程中运行，使用observeOn(Schedulers.newThread())就可以了。 例子 先来一个demo12345678910Observable.just(\"test\") //发射数据.observeOn(Schedulers.newThread()) //切到新线程.map(str -&gt; str+\"1\") //将数据加上字符串1.subscribeOn(Schedulers.immediate())//指定观察者执行的线程.subscribe(new Action1&lt;String&gt;() &#123; //订阅者 @Override public void call(String s) &#123; System.out.println(s); &#125;&#125;); 设置线程 subscribeOn(): 设置subscribe()订阅所发生的线程，即 call() 执行的线程。只有第一次设置生效，之后多次调用无效 observeOn(): 设置Observer运行的线程，设置后线程马上切换。 线程控制器 Schedulers提供了几种线程控制器 Schedulers.computation() 用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量Schedulers.from(executor) 使用指定的Executor作为调度器Schedulers.immediate() 在当前线程立即开始执行任务Schedulers.io() 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器Schedulers.newThread() 为每个任务创建一个新线程Schedulers.trampoline() 当其它排队的任务完成后，在当前线程排队开始执行","categories":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/categories/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/tags/RxJava/"},{"name":"异步编程","slug":"异步编程","permalink":"http://wucb.top/tags/异步编程/"}]},{"title":"3.RxJava功能大全(转)","slug":"3.RxJava功能大全(转)","date":"2017-12-06T02:54:47.000Z","updated":"2017-12-08T00:08:44.000Z","comments":true,"path":"2017/12/06/3.RxJava功能大全(转)/","link":"","permalink":"http://wucb.top/2017/12/06/3.RxJava功能大全(转)/","excerpt":"","text":"ReactiveX 都有哪些操作呢请看 原文地址可以快速略过，反正也记不住，用的时候查一次，大概开一下了解一下都有说明功能 创建操作用于创建Observable的操作符 变换操作这些操作符可用于对Observable发射的数据进行变换 过滤操作这些操作符用于从Observable发射的数据中进行选择 组合操作组合操作符用于将多个Observable组合成一个单一的Observable 错误处理这些操作符用于从错误通知中恢复 辅助操作一组用于处理Observable的操作符 条件和布尔操作这些操作符可用于单个或多个数据项，也可用于Observable 算术和聚合操作这些操作符可用于整个数据序列 连接操作一些有精确可控的订阅行为的特殊Observable 转换操作To — 将Observable转换为其它的对象或数据结构Blocking 阻塞Observable的操作符 操作符决策树几种主要的需求 直接创建一个Observable（创建操作）组合多个Observable（组合操作）对Observable发射的数据执行变换操作（变换操作）从Observable发射的数据中取特定的值（过滤操作）转发Observable的部分值（条件/布尔/过滤操作）对Observable发射的数据序列求值（算术/聚合操作）","categories":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/categories/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/tags/RxJava/"},{"name":"异步编程","slug":"异步编程","permalink":"http://wucb.top/tags/异步编程/"}]},{"title":"4.RxJava第一个实例","slug":"4.RxJava第一个实例","date":"2017-12-05T02:49:36.000Z","updated":"2017-12-08T00:08:44.000Z","comments":true,"path":"2017/12/05/4.RxJava第一个实例/","link":"","permalink":"http://wucb.top/2017/12/05/4.RxJava第一个实例/","excerpt":"","text":"前言： 还是基于考生和监考老师的例子，对RxJava中的几个概念进行理解 maven依赖12345&lt;dependency&gt; &lt;groupId&gt;io.reactivex&lt;/groupId&gt; &lt;artifactId&gt;rxjava&lt;/artifactId&gt; &lt;version&gt;1.0.10&lt;/version&gt;&lt;/dependency&gt; 先有一个考生Observable 12345678 Observable&lt;String&gt; student = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; //subscriber 订阅者对象 @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"我要交卷\"); //发射一个\"我要交卷\"的String（调用订阅者对象方法） subscriber.onCompleted();//发射完成，必须写这个，不写发布出去 &#125;&#125;); 上面代码就是说创建了一个发射源，并且发出了一个字符串。这个创建发射数据源的方式有很多 再有一个监考老师Observer 12345678910111213Observer&lt;String&gt; teach = new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"收到你的试卷了\"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; System.out.println(\"收到请求\"+s); &#125;&#125;; 上面代码就是创建了一个接收源，重写的几个方法onCompleted(当接收完了) onError（当错误） onNext（当收到数据） 老师进入考场了开始监考subscribe 1student.subscribe(teach); 上面这句就是接收源订阅发送源，也就是老师开始监考学生。 有个同学作弊Subject 1234PublishSubject&lt;String&gt; student2 = PublishSubject.create();student2.map(string -&gt; \"你的答案给我了,我也要交卷了\");student.subscribe(student2);//接收student的数据student2.subscribe(teach);//一样被teach监考 上面代码，Subject既能接收也能发送。 班主任在外边action0 1234567Action1 headTeacher = new Action1() &#123; @Override public void call(Object o) &#123; System.out.println(\"-------------\"+o); &#125;&#125;;student.subscribe(headTeacher); 班主任等你交卷了出来有话和你说为啥用Action1而不用Observer呢，班主任只关心你考完了，在考场里的其他动作，她没必要处理","categories":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/categories/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/tags/RxJava/"},{"name":"异步编程","slug":"异步编程","permalink":"http://wucb.top/tags/异步编程/"}]},{"title":"2.RxJava概念","slug":"2.RxJava概念","date":"2017-12-05T01:54:32.000Z","updated":"2017-12-08T00:08:44.000Z","comments":true,"path":"2017/12/05/2.RxJava概念/","link":"","permalink":"http://wucb.top/2017/12/05/2.RxJava概念/","excerpt":"","text":"概念RxJava是Java VM上一个灵活的、使用可观测序列来组成的一个异步的、基于事件的库。上面的这句话觉得不好理解的可以理解异步 观察者 异步 观察者模式从使用的角度来说，可能也只有异步的个点是最强需求了。先列几个RxJava中基本的概念1234561. Observable（被观察者、发射源） 2. Observer/Subscriber（观察者、接收源）3. Subject （可被观察也可观察别人、既可充当发射源，也可充当接收源）4. Subscriber（订阅者、观察者对象）3. Action0 （RxJava中的一个接口，只有一个call方法，没有返回值)4. Func0（与Action0相似， 有返回值） 举个例子：你在考场考试，监考官在观察你（也就是订阅了）有没有作弊、喧哗或要交卷了。那么这个是时候呢Observable也就是你，是一个被观察者Observer/Subscriber 也就是监考官就是在观察你。Observable发出一个数据。也就是你交卷了。Observer/Subscriber 就会受到数据（你交的试卷）","categories":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/categories/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/tags/RxJava/"},{"name":"异步编程","slug":"异步编程","permalink":"http://wucb.top/tags/异步编程/"}]},{"title":"1.RxJava综述","slug":"1.RxJava综述","date":"2017-12-04T05:27:02.000Z","updated":"2017-12-08T00:08:44.000Z","comments":true,"path":"2017/12/04/1.RxJava综述/","link":"","permalink":"http://wucb.top/2017/12/04/1.RxJava综述/","excerpt":"","text":"写在前面 文档：rxjava中文文档 Git：ReactiveX/RxJavaRx是什么来看看官方的解释rx：ReactiveX微软给的定义是，Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：Rx = Observables + LINQ + Schedulers。 RxJava是什么RxJava就是一种用Java语言实现的响应式编程，来创建基于事件的异步程序一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库关键词：异步 响应式编程 基于事件 Rxjava有什么用大白话：实现异步调用，少写代码，方便数据操作 为什么要使用Rxjava你的项目需要异步调用我觉得这个最关键的，异步和熔断","categories":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/categories/RxJava/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://wucb.top/tags/RxJava/"},{"name":"异步编程","slug":"异步编程","permalink":"http://wucb.top/tags/异步编程/"}]},{"title":"maven离线使用，本地明明有却提示找不到jar","slug":"maven离线","date":"2017-11-29T03:19:55.000Z","updated":"2017-11-30T08:30:57.942Z","comments":true,"path":"2017/11/29/maven离线/","link":"","permalink":"http://wucb.top/2017/11/29/maven离线/","excerpt":"","text":"有的时候我们的开发环境中没有网络，也没有私服，对就是这样无奈（无语），明明本地maven仓库中有该jar包，却提示没有。不妨尝试如下的操作，可能会产生意想不到的结果哦。 1) 删除maven本地仓库repository中名字为_remote.repositories的所有文件。2) 删除maven本地仓库repository中.lastUpdated为后缀的所有文件。 执行以上两步，刷新你的项目，然后就可以测试maven打包了。","categories":[{"name":"maven","slug":"maven","permalink":"http://wucb.top/categories/maven/"}],"tags":[{"name":"maven，疑难杂症","slug":"maven，疑难杂症","permalink":"http://wucb.top/tags/maven，疑难杂症/"}]},{"title":"Markdown的扩展格式","slug":"Markdown","date":"2017-11-27T06:03:44.000Z","updated":"2017-11-27T07:58:46.025Z","comments":true,"path":"2017/11/27/Markdown/","link":"","permalink":"http://wucb.top/2017/11/27/Markdown/","excerpt":"","text":"说明 Markdown 是为网络书写者而生的方便text-to-HTML工具，它允许人们用一种易读易写的纯文本格式进行书写，然后将其转化成XHTML或HTML 扩展格式 常用扩展Markdown格式有: GFM PHP Markdown Extra MultiMarkdown Pandoc Markdown等。 GFM 这种衍生Markdown叫做Github Flavored Markdown，简称 GFM 详细说明：https://help.github.com/categories/writing-on-github/ 与原生Markdown的主要不同： 围栏式（Fenced）代码块：在代码的上下增加3个反引号```，可选择性定义代码语种，并支持代码高亮。 列表嵌套方法：改为每次嵌套缩进两个空格。 支持任务列表：在每个列表项目加入[ ]，完成任务用 [x]，如：- [x] 任务说明。 支持简单表格 支持emoji表情 删除线：~~无空格包裹。PHP Markdown Extra Markdown Extra是PHP Markdown的一个扩展，实现了当前Markdown语法所不具备的一些功能。 Markdown Extra在PHP Markdown Lib中作为单独的解析器类提供 详细的语法说明：https://michelf.ca/projects/php-markdown/extra/ 与原生Markdown的主要不同： 内嵌html：块标签可以缩进不超过3个空格，且可以在块标签中选择性使用markdown语法（方法略）。 可以为区块元素设置id和class属性，实现文章内部跳转，方法略。 区块代码：与GFM相似，可以使用栅栏方式，在代码上下行用3个或以上波浪号~或反引号`包裹，亦支持代码高亮。 表格：同GFM 支持定义列表：方法略 支持脚注：[^1]，在新行[^1]: 脚注内容 注意：脚注名字必须唯一 支持缩略语：方法略 强调：两字词中间的下划线不会被解释成强调 MultiMarkdown 原生markdown文档只能从纯文本转换HTML。而MultiMarkdown则是扩大了原生markdown的转换范围，让其可以方便的转换成HTML/XHTML LaTeX (which can be processed into a PDF) OpenDocument Text document OPML 详细的语法说明见：http://fletcherpenney.net这是语法快速查询表：https://rawgit.com/fletcher/human-markdown-reference/master/index.html 与原生Markdown的主要不同： 支持元数据：标题、作者、日期等信息，兼容部分YAML。 支持交叉引用。 支持添加链接和图片的属性。 图片可以作为区块元素：如果一个图片语言独立成段，会被自动解释为区块元素，图片下会添加一行图片说明。 支持部分复杂表格：兼容PHP Markdown Extra的表格，同时可以——多行表头，单元格横向合并，表格分区，表格下行表格说明等。 支持脚注：同PHP Markdown Extra中的脚注。 支持参考文献（Citations） 支持定义列表：同PHP Markdown Extra。 支持缩略语（Abbreviations）：同PHP Markdown Extra。 支持栅栏式区块代码：上下行3到5个反引号包裹代码，可定义语法种类，选择性语法高亮。 注意：首尾行的反引号数量要一致。 支持MathJax公式（区块与行内）：区块公式在新行用\\[和\\]包裹，或首尾用两个dollar$$包裹。行内公式用\\(和\\)包裹，或首尾各用一个dollar$包裹。 支持上标与下标：上标为单个字符，前面加^，为多个字符，用^包裹。下标为单个字符，前面加~，为多个字符，用~包裹。 支持术语表 支持修订功能（CriticMarkup）：可以显示修订痕迹 删除：{–删除的文本 –} 添加：{++新增的文本 ++} 替换：{删除的文本~&gt;新增文本} 高亮：{==高亮的文本==} 备注：{&gt;&gt;备注文本&lt;&lt;} 内嵌HTML，可在块级HTML中选择性地添加MultiMarkdown语法。 支持内嵌其他文件，txt、tet、fodt、html等 换行方式改为行末使用\\换行。（原生Markdown使用2个空格换行） 支持目录：添加目录Pandoc’s Markdown Pandoc本身是一个多格式文档的转换工具，所以Pandoc Markdown与MultiMarkdown的设计目的相似，使Markdown可以转换成更多的不同格式，因为Pandoc支持的格式很多，这也就使的Pandoc’s Markdown非常的丰富，比如表格就有4种不同的书写方法。 详细的语法说明见：http://pandoc.org/MANUAL.html#pandocs-markdown翻译的中文版：http://pages.tzengyuxio.me/pandoc/ 与原生Markdown的主要不同： 强制换行支持两种方式：行尾两个空格换行，反斜杆换行。 Atx式标题之前一定要预留空行。标题行尾可加标题识别符。 区块引用之前一定要预留空行。 围栏式区块代码可以用3个以上波浪线或反引号组成的行包裹代码。之前必须留空行。 支持行区块 不同形式的列表会生成不同的列表 支持连续编号的范例清单，范例项目应用与整个文档，不局限与单一清单 支持定义列 支持简单表格、多行表格、格框表格和管线表格四种表格样式 支持文件标题区块（类似元数据） 支持删除线 支持上标、下标 支持数字公式 支持内嵌TeX CommonMark由于创始人自2004年Markdown诞生之后就没有更新过Markdown语法，众多的遗留问题没有得到解决，加上扩展语法的自由发展和Markdown编辑器的涌现，导致了很严重的方言和兼容性问题。因此有人希望对Markdown语法进行规整和统一，建立一套Markdown的语法规范，而CommonMark正是这样产物。CommonMark与一般的衍生语法不同，它的目的不是扩展Markdown的功能，而是解决原生markdown的遗留问题和方言问题，规范Markdown的书写，成为Markdown的标准。可惜此举得到Markdown创始人John Gruber的强力反对，所以至今CommonMark并没有得到广泛的认可。但是其实就CommonMark本身而言，它规范了Markdown的各项语法，有许多可取之处。CommonMark的语法说明是所有markdown语法说明中最长最详细的，优先问题、缩进问题、空行问题、嵌套问题等等容易出现语法冲突的地方都作了非常详细的说明 详细的语法说明：http://spec.commonmark.org/ 与原生Markdown的主要不同： 定义了优先级别：区块语法的优先级别大于行内语法。 支持围栏式区块代码 支持1）作为有序列表的项目标记 支持 \\作为换行符。 列表嵌套采用行首内容对齐，而非4个空格 Setext式标题支持多行 更多Markdown相关知识请访问https://sspai.com/post/37264","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://wucb.top/categories/Markdown/"}],"tags":[{"name":"markdown分类","slug":"markdown分类","permalink":"http://wucb.top/tags/markdown分类/"},{"name":"md","slug":"md","permalink":"http://wucb.top/tags/md/"}]},{"title":"Hello World","slug":"hello-world - 副本","date":"2017-11-24T07:03:27.467Z","updated":"2017-11-23T03:12:52.338Z","comments":true,"path":"2017/11/24/hello-world - 副本/","link":"","permalink":"http://wucb.top/2017/11/24/hello-world - 副本/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"http://wucb.top/categories/Hexo教程/"}],"tags":[]}]}